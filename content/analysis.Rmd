---
title: Analysis
description:
toc: true
featuredVideo:
featuredImage: https://upload.wikimedia.org/wikipedia/commons/7/77/Pebbleswithquarzite.jpg
draft: false
---

This comes from the file `content/analysis.Rmd`.

We describe here our detailed data analysis.

[second analysis page](/analysis2/)

## Motivation:

*Firstly, We want to know what factors affect and have relationships with the temperature. We want to test various variables such as “Year”, “Regions”, “CO2 emission”, “Coal”, “Gas”, “population”, “forest area”, and “Oil”. We are interested in answering whether those variables will lead to changes in the temperature and assume that these variables can affect or are related to temperature. We also want to compare these relationships and know which variable among those actually affects temperature most. Finally, we are wondering if our conclusions are valid and correct. 

```{r,warning=FALSE,message=FALSE}
library(tidyverse)
library(GGally)
library(patchwork) 
library(tmap)
library(sf)
library(spiralize)
library(ggpmisc)
library(car)

source(
  here::here("static", "load_and_clean_data.R"),
  echo = FALSE)
```
## General Trend:

*In order to get the relationship between year and temperature, we firstly draw the figure of years and CO2emission. It is found that with the increase of years, co2 emission also increased. Then we have the plot and find that CO2emission is also directly proportional to the weather. Therefore, we can finally get: as the years increase, the co2 emissions increase, resulting in an increase in temperature which verify our one assumption.

```{r 1,warning=FALSE,message=FALSE}
World_data %>% 
  ggplot(aes(y=CO2emission,x=as.numeric(Year)))+geom_point()+
  labs(y="CO2 World emission")
(summary(lm(CO2emission~as.numeric(Year),data=World_data)))

World_data %>% 
  ggplot(aes(x=CO2emission,y=temperature))+geom_point()+
  labs(x="CO2 World emission",y="Global temp anormaly")+geom_smooth()
(summary(lm(temperature~CO2emission,data=World_data)))
acf(World_data$CO2emission)
pacf(World_data$CO2emission)

World_data %>% 
  ggplot(aes(x=log(CO2emission),y=temperature))+geom_point()+
  labs(x="CO2 World emission",y="Global temp anormaly")+geom_smooth()

World_data %>% 
  ggplot(aes(y=temperature,x=(CO2emission-lag(temperature))/lag(CO2emission)))+geom_point()+
  labs(x="CO2 World emission",y="Global temp anormaly")+geom_smooth()
```

## Visualization:
*Secondly, we get the map that shows the degree of temperature change in each region over a fixed period of time. But all we know from this map is that the magnitude of the temperature change is different for each region. We do not know what internal changes are causing the temperature to change more. Maybe it's because of changes in the terrain or just because of the geography. We have no way of knowing and this is one limitation of our anaylsis.From this data, we can also plot the average change in temperature from year to year. As we can see, the images still appear to be positively proportional, which again confirms our inferences about the relationship between year and temperature.



## Modeling:

*Then, we draw a correlation matrix to see the correlation between each parameters. From the plot we find that all the parameter is highly correlated with the temperature. We let temperature always be the Y-axis, and the variables "CO2 emission", "Coal", "Gas", "population", "forest area" and "Oil" are used as the X-axis respectively. We get the conclusion that the relationship between forest area and temperature is negative. For other variables, the greater the quantity, the higher the temperature. And we find that when only test one specific parameters. All the parameter is significant when testing the linear model.However, there seems to be a problem that these parameter are highly correlated with each other, the problem of multicollinearity may appear in our model when add all the parameter in the linear model.Then we run a model with all the parameter add together. The result shows that only the parameter coal is significant. However the result indicate that add all parameter together is not a good choice. We then use the backward step wise AIC to do the model selection. The result is the parameter coal and CO2emission is significant when predicting the temperature. And our final model is temperature ~ Coal + CO2emission, the p-value of this model is small enough and the R^2 is 0.8259, which illustrate that our model can represent most of the data.


```{r mod,warning=FALSE,message=FALSE}
attach(World_data)
World_data %>% select(-Country_Name, -Year) %>%
  ggpairs(upper = list(continuous = wrap('points', alpha = .3, size = .1)),
          lower = list(continuous = wrap('cor', size = 4)),
          axisLabels = 'none', progress = FALSE) 

World_data %>% ggplot(aes(as.numeric(Year), temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'year', y = 'temperature', title = 'The Trend of Temperature')
temp_year_mod = lm(temperature ~ as.numeric(Year))
summary(temp_year_mod)

World_data %>% ggplot(aes(CO2emission, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'CO2', y = 'temperature', title = 'Temperature Change with CO2 Emission')
temp_co2_mod = lm(temperature ~ CO2emission)
summary(temp_co2_mod)

World_data %>% ggplot(aes(Coal, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'Coal Use', y = 'temperature', title = 'Temperature Change with Coal Use')
temp_coal_mod = lm(temperature ~ Coal)
summary(temp_coal_mod)

World_data %>% ggplot(aes(Gas, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'Gas Use', y = 'temperature', title = 'Temperature Change with Gas Use')
temp_gas_mod = lm(temperature ~ Gas)
summary(temp_gas_mod)

World_data %>% ggplot(aes(population, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'Population', y = 'temperature', title = 'Temperature Change with Population')
temp_popu_mod = lm(temperature ~ World_data$population)
summary(temp_popu_mod)

World_data %>% ggplot(aes(forest_area, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'Forest Area', y = 'temperature', title = 'Temperature Change with Forest Area')
temp_fore_mod = lm(temperature ~ World_data$forest_area)
summary(temp_fore_mod)

World_data %>% ggplot(aes(Oil, temperature)) + geom_smooth(se = FALSE) +
  labs(x = 'Oil', y = 'temperature', title = 'Temperature Change with Oil Use')
temp_oil_mod = lm(temperature ~ Oil)
summary(temp_oil_mod)

mult_lm = lm(temperature ~ World_data$population + World_data$forest_area +Gas + Oil + Coal + CO2emission)
summary(mult_lm)

step(mult_lm, direction = 'both')
final_mod = lm(temperature ~ Coal + CO2emission)
summary(final_mod)
```

## Conclusion:

*Finally, we validate our results through two ways. One of them checks for Normality by drawing the relationship between 'Theroretical Quantiles' and 'Sample Quantiles'. From the plot we can find that although most of the point seems follow the line, however some points in the middle part has it's own trend, which means our model is not quite good enough. Secondly, the relationship between fitted values and standardized residuals is plotted to check for Constant Variance. It is obvious that the residual is not normally distributed since in the right lower corner there is a empty space. This may happen because there might be some multicollinearity happens between the amount usage of coal and CO2emission. However this is our limit, since most of the data that we collect such as "population", "deforestation", the use of "fossil fuel" more or less has some correlation with the CO2emission, and the CO2emission is the major cause of the climate change. Our conclusion is that CO2emission contributes a lot to the climate change. 


```{r checking,warning=FALSE,message=FALSE}
y_hat = final_mod$fitted.values
diagnostics = lm.influence(final_mod)
hat = diagnostics$hat
sigmasq_hat = sum(final_mod$residuals ^ 2) / final_mod$df.residual
std_res = final_mod$residuals / sqrt(sigmasq_hat * (1 - hat))
diag <- tibble(y_hat, std_res)

diag %>% ggplot(aes(sample = std_res)) +
  geom_qq() + geom_qq_line() +
  labs(x = 'Theroretical Quantiles', y = 'Sample Quantiles',
       title = 'Checking for Normality')

diag %>% ggplot(aes(y_hat, std_res)) +
  geom_point() + geom_hline(yintercept = c(-2, 2), color = 'blue') +
  labs(x = 'fitted values', y = 'standardized residuals',
       title = 'Checking for Constant Variance')
```



```{r}
all_developed = c("Switzerland","Norway","Iceland","Hong Kong","Australia","Denmark","Sweden","Ireland","Germany","Netherlands","Finland","Singapore","Belgium","New Zealand","Canada","Liechtenstein","Luxembourg","United Kingdom","Japan","South Korea","United States","Israel","Malta","Slovenia","Austria","United Arab Emirates","Spain","France","Cyprus","Italy","Estonia","Czechia","Greece","Poland","Bahrain","Lithuania","Saudi Arabia","Portugal","Latvia","Andorra","Croatia","Chile","Qatar","San","Slovakia","Hungary","Argentina","Turkey","Montenegro","Kuwait","Brunei","Russia","Romania","Oman","Bahamas","Kazakhstan","Trinidad and Tobago","Costa Rica","Uruguay","Belarus","Panama","Malaysia","Georgia","Mauritius","Serbia","Thailand")

CO2_clean_1 %>% filter(!Country %in% c('World','European Union (27)')) %>% mutate(developed = ifelse(Country %in% all_developed, 'Developed', 'Developing')) %>% group_by(Country) %>% 
  transmute(meanCO2 = mean(CO2emission,rm.na = TRUE), developed = developed) %>%
  distinct(Country, meanCO2, developed) %>%
  ggplot(aes(developed, meanCO2,color = developed)) + geom_boxplot() + ylim(-10,100) +
  geom_jitter(shape=16, position=position_jitter(0.2), alpha = .4) + 
  labs(title = 'Mean Emission of CO2 Form 1990-2018', x = 'Development Phase',
       y = 'Mean Emission of CO2')

TemChange_Year %>% mutate(developed = ifelse(Area %in% all_developed, 'Developed', 'Developing')) %>%
  filter(year %in% 1990:2018) %>% group_by(Area) %>% 
  transmute(meanTempChange = mean(change,rm.na = TRUE), developed = developed) %>%
  distinct(Area, meanTempChange, developed) %>%
  ggplot(aes(developed, meanTempChange, color = developed)) + geom_boxplot() +
  geom_jitter(shape=16, position=position_jitter(0.2), alpha = .4) + 
  labs(title = 'Mean Temperature Change Form 1990-2018', x = 'Development Phase',
       y = 'Mean Temperature Change')
```


Start at here
## Motivation:
In order to get the relationship between year and temperature, we firstly draw the figure of temperature and CO2emission with yeas individually, then we draw the plow between temperature and CO2emission to find whether or not there is a correlation between them.

1.TEM & Year
```{r}
Temp_Year_Mod = World_data %>% mutate(Year = as.numeric(Year)) %>% 
  lm(temperature ~ Year, data = .)

World_data %>% mutate(Year = as.numeric(Year) ) %>% ggplot(aes(Year, temperature)) +
  geom_point() + stat_poly_line(se = FALSE) + 
  stat_poly_eq(mapping = use_label(c('eq', 'adj.R2', 'p', 'AIC'))) +
  labs(title = 'Temperature over Time', y = '°C',
       caption = 'Compared with the Average Temperature in 20th Century')

broom::tidy(Temp_Year_Mod) %>% select(term, estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()
```
The is the plot between the temperature and years from 1990 to 2016. The temperature is not labeled in actual temperature in  Celsius, instead it is measured in the difference between that year and the average temperature in 20th Century. As we can see, the change in temperature  has been fluctuating between these 26 years. The overall all trend of temperature is increasing by years, we also we draw a linear line to represent the trend between these two variable. It is clear that the trend of temperature almost follow the model: temperature=0.018*year-35.5. The R square adjusted is 0.73, It means the data follow the model well and every one unit increase in year will also increase 0.018 towards the intercept when predicting the temperature.


comment
2.CO2 & Year
```{r}
CO2_Year_Mod = World_data %>% mutate(Year = as.numeric(Year) ) %>% 
  lm(CO2emission/1000 ~ Year, data = .)

World_data %>% mutate(Year = as.numeric(Year)) %>% ggplot(aes(Year, CO2emission/1000)) +
  geom_point() + stat_poly_line(se = FALSE) + 
  stat_poly_eq(mapping = use_label(c('eq', 'adj.R2', 'p', 'AIC'))) + 
  labs(title = 'CO2 Emission over Time', y = 'CO2 Emission/1000',
       caption = 'CO2 Emission has been divided by 1000')

broom::tidy(CO2_Year_Mod) %>% select(term, estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()
```
The is the plot between the CO2 emission and years from 1990 to 2016. The unit of CO2 is labeled in 1000 MtCO₂e. As we can see, the change in CO2 emission  has been fluctuating between these 26 years, but the trend is clear. The overall all trend is increasing by years, we also we draw a linear line to represent the trend between these two variable. It is clear that the trend of CO2 emission almost follow the model: CO2 emission=0.546*year-1064.614. The R square adjusted is 0.96, It means the data is highly correlated with years and every one unit increase in year will also increase 0.546 towards the intercept when predicting the CO2 emission.

```{r}
acf(World_data$CO2emission, main="")
pacf(World_data$CO2emission, main="")
```
These two plot shows whether time series appears in this data. The autocorrelation plot is a geometric plot, the partial autocorrelation plot has one significant abnormal point, which indicates the CO2 emission follows a AR(1) model, and the CO2 emission of a certain year is highly correlated with the previous year's data. 


3.TEM&CO2
```{r}
Temp_CO2_Mod = World_data %>% lm(temperature ~ log(CO2emission), data = .) %>% summary()

World_data %>% ggplot(aes(log(CO2emission), temperature)) + geom_point() + 
  stat_poly_line(se = FALSE) + 
  stat_poly_eq(mapping = use_label(c('eq', 'adj.R2', 'p', 'AIC'))) +
  labs(title = 'Temperature by the Logarithm of CO2 Emission', y = 'Temperature',
       x = 'Logarithm of CO2 Emission')

broom::tidy(Temp_CO2_Mod) %>% select(term, estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()
```
The is the plot between the CO2 emission and temperature from 1990 to 2016. We are interesting to find the relationship between CO2 emission and temperature. As we can see, the change in temperature is increasing when the CO2 emission is also increasing from 22500 to around 26000. Then the temperature does not change as the CO2 emission continue increase. When the CO2 emission is around 31000, the temperature increase as the CO2 emission increase again. The overall all trend is there's a positive correlation between temperature and CO2 emission, we also we draw a linear line to represent the trend between these two variable. It is clear that the trend of these two variables almost follow the model: temperature=0.893*log(CO2 emission)-8.586. The R square adjusted is 0.68, It means 68% of the data can be explain by our model and and every one unit increase in log(CO2emission) will also increase 0.893 towards the intercept when predicting the temperature.


4.multi
```{r}
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
World_data %>% select(-Country_Name, -Year) %>% 
  rename(., Forest = forest_area, Pop = population, CO2 = CO2emission, Temp = temperature) %>% cor() %>%
  corrplot::corrplot(method = 'square', type = 'upper', diag = FALSE, tl.col = 'Black', tl.srt = 45,
                     tl.cex = .9,order = 'hclust', addCoef.col = "black", col = col(10000))
grid.text('The Correlation between Variables', .3 , .1)
```


```{r}
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot(M, method="color", col=col(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", #添加相关系数
         tl.col="black", tl.srt=45, #修改字体
         p.mat = p.mat, sig.level = 0.01, insig = "blank", #显著性筛选
         diag=FALSE 
         )

transform_World_data = World_data %>% mutate(forest_area = log(forest_area), population = log(population), 
                                         Gas = log(Gas), Oil = log(Oil),  Coal = log(Coal), 
                                         CO2emission = log(CO2emission)) %>% select(-Country_Name, -Year)

mult_full_model = lm(temperature ~ ., data = transform_World_data)
broom::tidy(mult_full_model) %>% select(term, estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()

step(lm(temperature ~ log(forest_area) + log(population) + log(Gas) + log(Oil) +
                         log(Coal) + log(CO2emission), data = World_data), direction = 'both')

final_mod = lm(temperature ~ log(Coal) + log(CO2emission), data = World_data)
broom::tidy(mult_full_model) %>% select(term, estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()

vif(final_mod) #不显示直接写数字可能更好 不太好做表

temp.res=resid(lm(temperature ~ log(Coal) + log(CO2emission), 
    data = World_data))
cbind(World_data, temp.res) %>% ggplot(aes(temperature, temp.res)) + geom_point() +
  labs(title = 'Residuals Plot', x = 'Temperature', y = 'Residual')

predict_model<-(-5.154e-05*World_data$Coal+1.217e-04*World_data$CO2emission-1.157e+00)
plot(density(predict_model),lwd = 5, col = "Green",main = "Density between Obsearvation and Predicted Model")
lines(density(World_data$temperature), lwd = 2)
```


5.ridge regression
As we state before, there are multicollinearity problem appear in the multiple linear regression, which will have the problem of over fitting when predicting the response variable. In order to make our estimation more accurate. We apply the ridge regression to reduce the influence of multicollinearity.Ridge regression, however, make a trade-off between bias and variance in prediction. By introducing a relatively small bias, we expect a large reduction in the variance, and thus in the mean-squared error.

As λ grows larger, the coefficients (as well as prediction variances) decrease, while the bias increases. Thus we have to select a λ to make a trade-off, so as to control the overall prediction error. 
```{r}
x = as.matrix(transform_World_data[,1:6])
y = as.matrix(transform_World_data[,7])

#glmnet::glmnet(x, y, alpha = 0)
#plot(MASS::lm.ridge(temperature ~ .,data = transform_World_data, lambda = seq(0, .1, .001)))
MASS::select(MASS::lm.ridge(temperature ~ .,data = transform_World_data, lambda = seq(0, .1, .001))) 
ridge_mod = ridge::linearRidge(temperature ~ .,data = transform_World_data, lambda = 0.1)

cbind(tibble(term = c('(Intercept)', 'Forest Area', 'Population', 'Gas','Oil','Coal',
                     'CO2 Emission')),as.tibble(summary(ridge_mod)$summaries$summary1$coefficients)) %>%
  rename(., p.value = `Pr(>|t|)`) %>% select(term, Estimate, p.value) %>% 
  mutate(across(where(is.numeric), ~round(., 3))) %>% DT::datatable()


(Rsquare = sum((predicted - mean(y))^2)/sum((y - mean(y))^2))


```
After using the ridge regression, we choose to use the lambda=0.1, under this assumption, and all the parameter is using log transformation to reach normality. we come up with a table of the summary of the ridge regression. The output is quite different from the output that we get in the multiple linear regression. Instead of only have coal and CO2emission, we have 6 parameters here, which are "Forest area", "Population", "Gas", "Oil", "Coal", and "CO2emission". By checking the p-value of these parameter, only the p-value for "Coal" is larger than 0.05, which is not significant in this model. So our final model is Temperature=-0.13*log(Forest area)+0.317*log(Population)+0.111*log(Gas)+0.46*log(Oil)+0.14*log(CO2 Emission)-9.05. We also calculate the R square of the model is 0.709, which means around 71% of the data can be explained by our ridge model. The coefficient of "Forest area" is -0.13, which mean every one unit decrease in the log(Forest area) will increase 0.13 towards the intercept to predict the response variable. The coefficient of other variables have the same meaning as the "Forest area" one I just explained.  
```{r}
predicted = as.matrix(cbind(rep(1, 27),transform_World_data[,1:6])) %*% coef(ridge_mod)
cbind(transform_World_data, predicted) %>% ggplot() + geom_point(aes(temperature, predicted))

```
In order to test the goodness of fit for our ridge model, we plot our predicted model with the observation data of temperature, this plot shows there is a positive linear correlation between the observation data and our predicted model. This plot confirmed our model did a good estimation on predicting the temperature, nearly all the points follow the positive relationship.

```{r}
transform_World_data %>% cbind(predicted) %>% mutate(Index = 1990:2016) %>% 
  ggplot() + geom_smooth(aes(Index, temperature), color = 'blue', se = FALSE) + 
  geom_smooth(aes(Index, predicted), color = 'red', se = FALSE)+ xlab("year")
```
Another way to test the goodness of fit of our model is draw the model and observation data together. In this plot, the blue line is the observation data, and the red line is our predicted model. Over all our model fit the trend of the observation well, although the original data is not as linear as we predicted, our model fit the trend of the temperature well. 



-------

